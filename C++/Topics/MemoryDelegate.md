# Управление памятью в C++
## Пример с ручным управлением памятью
```cpp

#include <iostream>
using namespace std;

// Простая структура для демонстрации
struct ItemT {
    int id;
    string name;
    // Можно добавить другие поля по необходимости
};

void processItem() {
    // Выделение памяти для объекта
    ItemT* ptr = new ItemT;
    
    int userInput;
    cout << "Введите число (0 для выхода): ";
    cin >> userInput;
    
    if (userInput == 0) {
        delete ptr;  // Освобождение памяти перед досрочным выходом
        return;
    }
    
    // Работа с объектом
    ptr->id = 1;
    ptr->name = "Test Item";
    cout << "Обработка элемента: " << ptr->name << endl;
    
    delete ptr;  // Освобождение памяти в конце функции
}

int main() {
    processItem();
    return 0;
}
```
### Разбор кода
1. Выделение памяти
`ItemT* ptr = new ItemT;`
- Оператор `new` выделяет память в куче (heap)
- Возвращает указатель на созданный объект
- Конструктор вызывается автоматически

2. Освобождение памяти
`delete ptr;`
- Оператор `delete` освобождает выделенную память
- Вызывает деструктор объекта
- Важно вызывать для каждого new

3. Проверка ввода пользователя
```cpp
if (userInput == 0) {
    delete ptr;
    return;
}
```
- Критически важно освобождать память перед досрочным выходом из функции
Иначе будет утечка памяти (memory leak)

## Проблемы ручного управления
- Утечки памяти:
    - Если забыть delete
    - Если между new и delete выбросит исключение
- Двойное удаление:
```cpp
delete ptr;
delete ptr;  // Ошибка!
```
- Висячие указатели:
```cpp
ItemT* p1 = new ItemT;
ItemT* p2 = p1;
delete p1;
// p2 теперь висячий указатель
```

## Безопасная альтернатива - умные указатели
### Пример с unique_ptr (C++11)
```cpp

#include <memory>

void safeProcessItem() {
    unique_ptr<ItemT> ptr(new ItemT);
    
    int userInput;
    cout << "Введите число: ";
    cin >> userInput;
    
    if (userInput == 0) {
        return;  // Память освободится автоматически
    }
    
    ptr->id = 1;
    ptr->name = "Safe Item";
    // Не нужно вызывать delete - память освободится при выходе из области видимости
}
```
#### Преимущества unique_ptr:

1. Автоматическое освобождение памяти

2. Запрещает копирование (предотвращает двойное удаление)

3. Нулевые накладные расходы

#### Рекомендации
- Всегда освобождайте память:
    - Каждому new должен соответствовать delete
    - Используйте RAII (умные указатели)

### Для сложных объектов:

```cpp

ItemT* item = new ItemT();
try {
    // Работа с объектом
} catch (...) {
    delete item;  // Освобождаем при исключении
    throw;
}
delete item;
```
В современном C++ предпочитайте:

- unique_ptr вместо сырых указателей

- make_unique (C++14) вместо new