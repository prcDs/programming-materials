# Рекурсивные функции в C++
## Факториал с использованием рекурсии
```cpp

#include <iostream>

/**
 * Рекурсивная функция вычисления факториала
 * @param b - число, для которого вычисляется факториал
 * @return факториал числа b
 */
int factorial(int b) {
    // Базовый случай рекурсии
    if (b <= 1) {
        return 1;
    }
    // Рекурсивный вызов
    return b * factorial(b - 1);
}

int main() {
    // Вычисление факториала числа 4
    std::cout << "4! = " << factorial(4) << "\n";  // Выведет 24 (4! = 4*3*2*1)
    
    // Дополнительные примеры
    std::cout << "5! = " << factorial(5) << "\n";  // 120
    std::cout << "6! = " << factorial(6) << "\n";  // 720
    
    return 0;
}
```
### Разбор кода
1. Базовый случай
```cpp

if (b <= 1) {
    return 1;
}
```
Останавливает рекурсию при достижении 1 или меньшего значения.
Без этого условия рекурсия уйдет в бесконечный цикл

2. Рекурсивный вызов
```cpp

return b * factorial(b - 1);
```
Функция вызывает саму себя с аргументом (b - 1).
Каждый вызов помещается в стек вызовов

3. Принцип работы для factorial(4)
```cpp
factorial(4)
4 * factorial(3)
4 * (3 * factorial(2))
4 * (3 * (2 * factorial(1)))
4 * (3 * (2 * 1)) = 24
```
## Ограничения рекурсии
- Глубина рекурсии - может привести к переполнению стека
- Производительность - рекурсивные вызовы обычно медленнее итеративных решений
- Память - каждый вызов требует места в стеке

## Итеративная версия (альтернатива)
```cpp

int factorial_iterative(int n) {
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    return result;
}
```
### Рекомендации по использованию рекурсии
- Используйте для задач, которые естественно описываются рекурсивно (деревья, графы)
- Всегда определяйте четкий базовый случай
- Для вычислений предпочитайте итеративные решения
- Учитывайте ограничение глубины рекурсии